-- general lua utilities
--
--
--
local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local r = ls.restore_node
local events = require("luasnip.util.events")
local ai = require("luasnip.nodes.absolute_indexer")
local extras = require("luasnip.extras")
local l = extras.lambda
local rep = extras.rep
local p = extras.partial
local m = extras.match
local n = extras.nonempty
local dl = extras.dynamic_lambda
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local conds = require("luasnip.extras.expand_conditions")
local postfix = require("luasnip.extras.postfix").postfix
local types = require("luasnip.util.types")
local parse = require("luasnip.util.parser").parse_snippet
local ms = ls.multi_snippet
local k = require("luasnip.nodes.key_indexer").new_key
local util = require("luasnip.util.util")
local node_util = require("luasnip.nodes.util")
local P = { }
utils = P

P.get_custom_date_fmt = function(args, snip, old_state, fmt)
  local fmt = fmt or "%Y-%m-%d"
  return sn(nil, i(1, os.date(fmt)))
end

P.get_ISO_8601_date = function()
  return os.date("%Y-%m-%d")
end

P.get_visual = function(_, parent)
  return sn(nil, i(1, parent.snippet.env.SELECT_RAW))
end
P.get_capture = function(_, snip, user_arg1, user_arg2, user_arg3)
  -- define args
  idx = user_arg1 or 1
  pre = user_arg2 or ""
  post = user_arg3 or ""
  return snip.captures[idx]
end

P.return_filename = function()     -- print current working file name (excluding suffix filetype)
  return vim.fn.fnamemodify(vim.fn.expand('%'),':t')
end
P.return_pwd = function()       -- print current working directory
  return vim.fn.getcwd()
end
-- dynamic node functionns from https://github.com/L3MON4D3/LuaSnip/wiki/Misc#dynamicnode-with-user-input
P.find_dynamic_node = function(node)
  -- the dynamicNode-key is set on snippets that are generated by a dynamicNode ONLY
  -- as its use is to refer to the dynamicNode that generated the snippet.
  while not node.dynamicNode do
    node = node.parent
  end
  return node.dynamicNode
end

P.external_update_id = 0
-- func_indx to update dynamicNode with various functions.
P.dynamic_node_external_update = function(func_indx)
  -- find current node and innermost dynamicNode it is within.
  local current_node = ls.session.current_nodes[vim.api.nvim_get_current_buf()]
  local dynamic_node = P.find_dynamic_node(current_node)

  -- identify current node in new snippet, if available
  P.external_update_id = P.external_update_id + 1
  current_node.external_update_id = P.external_update_id
  local current_node_key = current_node.key

  -- store current mode to allow restoring later.
  local insert_pre_call = vim.fn.mode() == "i"
  -- is byte-indexed! just be aware.
  local cursor_pos_end_relative = util.pos_sub(
    util.get_cursor_0ind(),
    current_node.mark:get_endpoint(1)
  )

  -- leave the current generated snippet
  node_util.leave_nodes_between(dynamic_node.snip, current_node)

  -- call update-function.
  local func = dynamic_node.user_args[func_indx]
  if func then
    -- same snippet passed to dynamicNode-function. Any output from func should be stored in it using an unused key.
    func(dynamic_node.parent.snippet)
  end

  -- last_args used to store the last args used to generate the snippet. 
  -- If this function is called, they will most likely not have changed,
  -- so they are set to nil, forcing an update.
  dynamic_node.last_args = nil
  dynamic_node:update() 
  -- the following is merely set dressing, and isn't necessarily required

  -- try to find the previously marked node
  local target_node = dynamic_node:find_node(function(test_node)
    return (test_node.external_update_id == P.external_update_id) or (current_node_key ~= nil and test_node.key == current_node_key)
  end)
  if target_node then
		-- the node that the cursor was in when changeChoice was called exists
		-- in the active choice! Enter it and all nodes between it and this choiceNode,
		-- then set the cursor.
		node_util.enter_nodes_between(dynamic_node, target_node)

		if insert_pre_call then
			-- restore cursor-position if the node, or a corresponding node,
			-- could be found.
			-- It is restored relative to the end of the node (as opposed to the
			-- beginning). This does not matter if the text in the node is
			-- unchanged, but if the length changed, we may move the cursor
			-- relative to its immediate neighboring characters.
			-- I assume that it is more likely that the text before the cursor
			-- got longer (since it is very likely that the cursor is just at
			-- the end of the node), and thus restoring relative to the
			-- beginning would shift the cursor back.
			-- 
			-- However, restoring to any fixed endpoint is likely to not be
			-- perfect, an interesting enhancement would be to compare the new
			-- and old text/[neighborhood of the cursor], and find its new position
			-- based on that.
			util.set_cursor_0ind(
				util.pos_add(
					target_node.mark:get_endpoint(1),
					cursor_pos_end_relative
				)
			)
		else
			node_util.select_node(target_node)
		end
		-- set the new current node correctly.
		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = target_node
	else
		-- the marked node wasn't found, just jump into the new snippet noremally.
		ls.session.current_nodes[vim.api.nvim_get_current_buf()] = dynamic_node.snip:jump_into(1)
	end
end

P.column_count_from_string = function(descr)
  -- won't work for all cases, but good starting point
  return #(descr:gsub("[^clm]", ""))
end

-- function for dynamicNode 
P.tab = function(args, snip)
  local cols = P.column_count_from_string(args[1][1])
  -- handle case where snip.rows is unset.
  if not snip.rows then
    snip.rows = 1
  end
  local nodes = {}
  -- track current insert-index.
  local ins_indx = 1
  for j = 1, snip.rows do
    -- use restoreNode to retain content while updating.
    table.insert(nodes, r(ins_indx, tostring(j).."x1", i(1)))
    ins_indx = ins_indx + 1
    for k = 2, cols do
      table.insert(nodes, t" & ")
      table.insert(nodes, r(ins_indx, tostring(j).."x"..tostring(k), i(1)))
      ins_indx = ins_indx + 1
    end
  table.insert(nodes, t{"\\\\", ""})
  end
  -- fix last node.
  nodes[#nodes] = t""
  return sn(nil, nodes)
end
-- End Function List --

return P

